<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>林宏宇的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="林宏宇的博客">
<meta property="og:url" content="http://linhongyu0090.github.io/index.html">
<meta property="og:site_name" content="林宏宇的博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="linhongyu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="林宏宇的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">林宏宇的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://linhongyu0090.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-C语言学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/17/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-04-17T12:35:39.000Z" itemprop="datePublished">2022-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/17/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">C语言学习笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li>变量是占用存储单元的，是具体存在的实体，在其占用的存储单元中可以存放数据。</li>
<li>判断一个浮点数是否为整数，只要将其强制转换为整形，得到其整数部分，若它等于整数部分，则说明这个浮点数为整数。&#x2F;&#x2F;浮点数可以看做整数部分和小数部分的和，注意判断是否为整数+0.9999999适用于正数，若是负数就不适用了。</li>
<li>冒泡排序要注意第二层循环的字母I ， j</li>
<li>#include&lt;string.h&gt;，strlen()可用于计算输入字符数组的长度</li>
<li>当时间为m点n分时，其时针与分针夹角的度数为：<br> （1）分针在时针前面：<br>n * 6 - (m * 30 + n * 0.5)<br> （2）分针在时针后面：<br>(m * 30 + n * 0.5) - n * 6<br> 依据此公式可以求出任意时刻时针与分针夹角的度数，计算起来非常便捷。如果题目中涉及到秒，我们可以先把秒换算为分，再套用上述规律和公式进行计算即可。</li>
<li>printf中打印出\要转译\</li>
<li>要表示三分之四,要写出（4.0&#x2F;3.0),若只写4&#x2F;3则会默认为整形的量，得到的结果是1</li>
<li>C语言中<em>号不要忘了写,比如（）（）之间,（）</em>（）,和字母与括号之间,p （）要写成p*（）</li>
<li><strong>二次方程 a &#x3D;&#x3D; 0 &amp;&amp; b &#x3D;&#x3D;0 &amp;&amp;c !&#x3D; 0 方程的解为0个</strong></li>
<li>输出一元二次方程的解的时候，若要求从小到大输出，需要判断a的正负来判断两个解的大小关系，不能认为+sqrt(b<em>b-4</em>a<em>c)的就大，-sqrt(b</em>b-4<em>a</em>c)的就小</li>
<li>计算小数后几位参数还是要用浮点型</li>
<li>计算a^b的时候，若只要输出最后几位的数字，每次只要去最后几位进行运算就行如 2^17,<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a = <span class="number">2</span>,b =<span class="number">17</span>,mul = <span class="number">1</span>;</span><br><span class="line">Int i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(I = <span class="number">1</span>;i&lt;=b;i++)&#123;</span><br><span class="line">​	mul *= a;</span><br><span class="line">​	mul = (<span class="type">int</span>)(mul)%<span class="number">10000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>银行规定贷款的金额不能超过房子总价的70%，而且必须是整数万元。M &#x3D; N * 7 &#x2F;10;&#x2F;&#x2F;若乘以0.7，0.7无法被精确表示，所以会错误！！！</li>
<li>若要求某个整数的十位数是多少，只要将其 &#x2F;10 % 10即可，除以10，是十位数变成个位数，再取余10得到的就是变成个位的十位数了<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(c &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">c = c / <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这样做就不一定是取十位数了，而是第二大的位数，只适用于几十的数</li>
<li>在c语言中</li>
</ol>
<ul>
<li><strong>使用%c输出的是字符本身</strong></li>
<li><strong>使用%d输出的是字符对应的ASCII</strong></li>
<li><strong>在ASCII中，小写英文字符 &#x3D; 大写英文字符+32</strong></li>
<li><strong>还有注意区分单引号’’和双引号””的区别</strong><br> <strong>单引号：字符，是可以进行加减的</strong><br> <strong>双引号：字符串</strong></li>
</ul>
<ol start="16">
<li>用gcc 编译一个文件出现如下错误：expected ‘&#x3D;’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘&lt;’ token<br>包含头文件时缺少“#”或者函数“{”与“}”没有成对的出现</li>
<li>语句都快注释完了，编译还是通不过，最后检查include，才发现，原来是include漏了致命重要的”#“号！！<br>我写成如下形式了： include &lt;stdio.h&gt;</li>
<li>tyepdef int (*psum)(int,int);<br>​   typedef拼写错误，如上，报的错误： error: expected ‘&#x3D;’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘int’</li>
<li>提示出现浮点错误，比如遇到除以0的情况</li>
<li><em>Switch</em>语句中记得在每一个语句末尾加上<em>break</em>，且在<em>switch</em>语句最后加上<em>default</em>的情况</li>
<li>***%02d* 表示存储两位数字 不足用*0*补上**</li>
<li>若在过程中使用另一个数组来存储值，记得将其初始化</li>
<li>定义全局变量是会被初始化为<em>0</em>，而局部变量不会被初始化</li>
<li>入字符时若遇到空格，<em>scanf</em>不能回自动跳过，而<em>gets</em>（）不会，<strong>但会识别上一行结束时输入的换行符*,*可以用*scanf*（“*&#x2F;n*”*)*将其省略</strong></li>
<li>PTA运行时错误，可能是数组越界，给数组范围扩大</li>
<li>如果下一行的gets（）没有输出东西，可能上一行的换行符号被其识别了，修改方法是在上一行的scanf里面加上\n</li>
<li>本题需要注意，对于大于-0.05的负数，如：-0.049526保留小数点后一位的结果为-0.0，不符合题目要求。因此，需要把落在区间 &lt; -0.5，-0.0 ] 内的结果取相反数后再输出，即把-0.0变成0.0 。</li>
<li>动态创建一个链表：动态内申请+模块化设计<ol>
<li>创建链表（创建一个表头表示整个链表）</li>
<li>创建节点</li>
<li>插入节点</li>
<li>删除节点</li>
<li>打印遍历链表</li>
</ol>
</li>
<li>数组使用时要初始化，不然数组中存储的数据是未知的</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://linhongyu0090.github.io/2022/04/17/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="cl239vo2m0002s6j0f89fe7es" data-title="C语言学习笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-UIkit学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/17/UIkit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-04-17T10:32:25.000Z" itemprop="datePublished">2022-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/17/UIkit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">UIkit学习笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Uikit学习笔记"><a href="#Uikit学习笔记" class="headerlink" title="Uikit学习笔记"></a>Uikit学习笔记</h1><ol>
<li><p>Dismiss让当前模态跳转的页面消失,返回到旧页面</p>
</li>
<li><p>一个对象可以同时拥有数据和功能</p>
</li>
<li><p>一般把变量放在方法的上面</p>
</li>
<li><p>lround()把slider.value四舍五入</p>
</li>
<li><p>Int(acr4_random(100))获取0～99内的一个随机整数</p>
</li>
<li><p>按住ctrl从View Controller（黄色图标的那个）往标签上拖（；注意：直接在标签上按住ctrl拖拽到view controller是没有用的，不要弄反了。动作是从view controller往下拖</p>
</li>
<li><p>仅仅是声明你有一个变量是不能自动创建一个相应的对象的。这个变量仅仅是对象的容器。你还需要实例化这个对象并且将它放入容器中。变量只是一个盒子，而对象是盒子中的内容。</p>
</li>
<li><p>如何定义一个委托<br>在iOS系统的SDK里，委托无处不在，所以我们最好记住它总是由三个步骤完成。<br> 1、你申明自己有能力成为一个委托——成为UITextField的委托你需要将UITextFieldDelegate写到视图控制器的类的声明中去。这样就告诉了编译器这个视图控制器可以处理来自文本框的消息。<br> 2、你让那个有问题的对象知道视图控制器愿意成为它的委托——在我们这个例子里，这个对象是UITextField。如果你忘记了告诉文本框它有一个委托，则这个文本框永远不会发送任何消息。<br> 3、执行委托方法——如果你没有对你发出的消息进行响应，那么委托根本不会成立。<br> 通常，委托方法是可选的，所以你不需要执行全部的委托方法。例如：UITextFieldDelegate实际上声明了七个方法但是你仅仅关心textField(shouldChangeCharactersIn, replacementString)这一个。<br>五步定义委托<br> 在两个对象之间创建委托可以用以下固定的步骤，比如对象A是对象B的委托，对象B发送消息返回给对象A，步骤如下：<br> 1、为对象B定义一个委托协议<br> 2、给对象B一个可选型的委托变量，这个变量必须是weak的。<br> 3、当某些事件触发时，让对象B发送消息到它的委托，比如用户点击Cancel或者Done按钮时，或者它需要一点信息时。你可以用语句delegate?.methodName(self,…)来完成这个功能。<br> 4、让对象A遵守委托协议。将协议的名称放入类声明，class的哪一行，并且执行协议中的方法列表。<br> 5、告诉对象B，对象A现在是你的委托了。</p>
</li>
<li><p>indexPath是一个指向表中具体某一行的一个简单的对象。当table view为cell请求数据源时，你可以通过这一行的indexPath.row属性的内部行号，就可以找到是哪个cell需要数据了。<br> delegate?.addItemController(<strong>self</strong>, didFinishAdding: item)<br> 复习一下整个过程：<br> 1、创建一个新的ChecklistItem对象<br> 2、将这个新创建的对象添加到数据模型中<br> 3、为它在table view插入一个新的cell</p>
</li>
<li><p><strong>let</strong> VC &#x3D; ViewControllerTwo()</p>
<p>​    VC.modalPresentationStyle &#x3D; .fullScreen</p>
<p>可以设置present的形式</p>
</li>
<li><p>import UIKit</p>
<p>class ViewController: UIViewController {</p>
<pre><code>override func viewDidLoad() &#123;
 
    super.viewDidLoad()
</code></pre>
</li>
</ol>
<p>​     </p>
<pre><code>        let btn1 = createButton(&quot;左上&quot;)
     
        self.view.addSubview(btn1)
</code></pre>
<p>​<br>​<br>​            let btn2 &#x3D; createButton(“右上”)<br>​<br>            btn2.frame.origin.x &#x3D; self.view.bounds.width - btn2.frame.width</p>
<pre><code>        self.view.addSubview(btn2)
</code></pre>
<p>​<br>​<br>​            let btn3 &#x3D; createButton(“左下”)<br>​<br>            btn3.frame.origin.y &#x3D; self.view.bounds.height - btn3.frame.height</p>
<pre><code>        self.view.addSubview(btn3)
</code></pre>
<p>​<br>​<br>​            let btn4 &#x3D; createButton(“右下”)<br>​<br>            btn4.frame.origin &#x3D; CGPoint(x: self.view.bounds.width - btn4.frame.width,</p>
<pre><code>            y: self.view.bounds.height - btn4.frame.height)
     
        self.view.addSubview(btn4)
</code></pre>
<p>​<br>​<br>​            let btn5 &#x3D; createButton(“居中”)<br>​<br>            btn5.center &#x3D; CGPoint(x: self.view.bounds.width &#x2F; 2,</p>
<pre><code>            y: self.view.bounds.height / 2)
     
        self.view.addSubview(btn5)
</code></pre>
<p>​<br>​<br>​            let btn6 &#x3D; createButton(“上中”)<br>​<br>            btn6.center.x &#x3D; self.view.bounds.width &#x2F; 2</p>
<pre><code>        self.view.addSubview(btn6)
</code></pre>
<p>​<br>​<br>​            let btn7 &#x3D; createButton(“左中”)<br>​<br>            btn7.center.y &#x3D; self.view.bounds.height &#x2F; 2</p>
<pre><code>        self.view.addSubview(btn7)
</code></pre>
<p>​<br>​<br>​            let btn8 &#x3D; createButton(“右中”)<br>​<br>            btn8.frame.origin.x &#x3D; self.view.bounds.width - btn8.frame.width</p>
<pre><code>        btn8.center.y = self.view.bounds.height / 2
     
        self.view.addSubview(btn8)
</code></pre>
<p>​<br>​<br>​            let btn9 &#x3D; createButton(“下中”)<br>​<br>            btn9.center.x &#x3D; self.view.bounds.width &#x2F; 2</p>
<pre><code>        btn9.frame.origin.y = self.view.bounds.height - btn9.frame.height
     
        self.view.addSubview(btn9)
     
    &#125;
</code></pre>
<p>​<br>​<br>​        func createButton(title: String) -&gt; UIButton {<br>​<br>            &#x2F;&#x2F;创建一个ContactAdd类型的按钮</p>
<pre><code>        let button:UIButton = UIButton(type:.Custom)
     
        //设置按钮大小
     
        //button.frame=CGRectMake(0, 0, 80, 50)
     
        button.frame.size = CGSize(width: 80, height: 50)
     
        //设置按钮文字
     
        button.setTitle(title, forState:UIControlState.Normal)
     
        button.backgroundColor=UIColor.orangeColor()
     
        return button
     
    &#125;
</code></pre>
<p>​     </p>
<pre><code>    override func didReceiveMemoryWarning() &#123;
     
        super.didReceiveMemoryWarning()
     
    &#125;

&#125;
</code></pre>
<ol start="12">
<li><p>func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {<br>&#x2F;&#x2F; Use this method to optionally configure and attach the UIWindow <code>window</code> to the provided UIWindowScene <code>scene</code>.<br>&#x2F;&#x2F; If using a storyboard, the <code>window</code> property will automatically be initialized and attached to the scene.<br>&#x2F;&#x2F; This delegate does not imply the connecting scene or session are new (see <code>application:configurationForConnectingSceneSession</code> instead).</p>
<p>self.window &#x3D; UIWindow(windowScene: scene as! UIWindowScene);<br>self.window?.backgroundColor &#x3D; UIColor.white;<br>let rootViewController &#x3D; ViewController();<br>self.window?.rootViewController &#x3D; rootViewController;<br>self.window?.makeKeyAndVisible();</p>
<p>guard let _ &#x3D; (scene as? UIWindowScene) else { return }<br>}</p>
</li>
<li><p>如果要添加手势 UILabel().isUserInteractionEnable &#x3D; true</p>
</li>
<li><p>command + shift + L 控件库</p>
</li>
<li><p>添加手势时候要实力化具体的手势	</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tap <span class="operator">=</span> <span class="type">UITapGestureRecognizer</span>(target: <span class="keyword">self</span>, action: <span class="keyword">#selector</span>(handleTap))</span><br><span class="line">        tapLabel.addGestureRecognizer(tap)</span><br></pre></td></tr></table></figure>
<p>如果只写UIGestureRecognizer则不行</p>
</li>
<li><p><strong>let</strong> onedegree &#x3D; CGFloat.pi &#x2F; 180</p>
<p>​     </p>
<p>​    imageView.transform &#x3D; CGAffineTransform(rotationAngle: CGFloat( 90 * onedegree))</p>
<p>iOS坐标系和数学上是相反的,正数为顺时针，负数为逆时针</p>
</li>
<li><p>&#96;&#96;&#96;swift<br>UIView.animate(withDuration: 3, delay: 0, options: .curveEaseIn){<br>    self.imageView.transform &#x3D; CGAffineTransform(translationX: 100, y: 100).scaledBy(x: 2, y: 2).rotated(by: 90 * onedegree)<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>18.在使用Autolayout时，发现leftAnchor和LeadingAnchor，让我很困惑<br>经过一番查阅后，理解如下:</p>
<p>在大部分情况下，leftAnchor(左)和LeadingAnchor(前导)相等，因为大部分情况下，文字阅读是从左至右的（英语，法语，西班牙语等）。左（和trailingAnchor(尾随)和右）可以互换使用。<br>在部分情况，如读取方向从右到左（例如希伯来语）的区域中，LeadingAnchor(前导)将是rightAnchor(右)</p>
<p>这就和文字阅读习惯，和语言有关。一般情况下我们是不用区分，除非考虑这些case</p>
<ol start="19">
<li>cornerradius设置为高度的一半就为圆形</li>
<li>给stackView添加子视图，要用arragnedSubviews</li>
<li>Command + f全部替换</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://linhongyu0090.github.io/2022/04/17/UIkit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="cl239vo2n0003s6j0hpk04tj9" data-title="UIkit学习笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Swift学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/17/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-04-17T10:31:31.000Z" itemprop="datePublished">2022-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/17/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Swift学习笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Swift学习笔记"><a href="#Swift学习笔记" class="headerlink" title="Swift学习笔记"></a>Swift学习笔记</h1><ol>
<li>类型判断type(of:)</li>
<li>拼接字符串()要放在字符串里面，里面也可加各种数据类型</li>
<li>类型别名typealias S &#x3D; String后面即可用S来代替String<br>只有字符串类型才可以通过+拼接,类型转换 Sting() 将其他类型转换为字符串型,将值打印出来，可以通过拼接字符串或者类型转换</li>
<li>??(空合运算符)语法，如果optional类型的值能解包出来，就返回解包出来的的值，为nil，则返回??后面的值</li>
</ol>
<ul>
<li>value &#x3D;  a! ?? 0</li>
<li>value &#x3D; a !&#x3D; nil a! : 0</li>
</ul>
<ol start="5">
<li>！在optional类型的值明确存在时候可使用，即解析一个可选类型的值<br>元组也属于值类型，赋值时会拷贝一份新的，也可在声明元组类型时给其中每一个参数起一个名称，就可以通过.名称来获取元组的值，而不需要索引<br>元组可以通过解构赋值eg:let (name1,name2) &#x3D; (1,2),swift可以通过类型推断判断<br>各个元组参数的类型，函数可以返回元组类型的值</li>
<li>用_可以匿名参数</li>
<li><strong>可选项绑定</strong>：a为optional类型的<br>if let value  &#x3D; a{<br>}else{<br>}</li>
<li>隐式解析：<br>var a:Int! &#x3D; 100(明确a有值，后续还可以给a赋值为nil，而普通类型不行)<br>var b:Int &#x3D; a</li>
<li>Swift中switch-case默认没有穿透效果，所以在每个case语句的句末不需要加break语句，可以在前一个语句末尾加上fallthrough使其具有穿透效果，即可以在匹配成功后继续执行下一个case语句</li>
<li>Switch可以在一个case中匹配多个值，case 1，2，3<br>case 1..&lt;9<br>case let(10,name)	进行解构赋值(拆分匹配)，如果value中第一个参数值为10，则把第二个参数的值赋给参数名称name<br>case let(name1,name2)where name1 &lt; name2 用where加上额外的条件</li>
<li>要跳过一定数目的值时使用：<br>for index in stride（from: to : by:){}<br>By为步长，包括开头，不包括结尾<br>for index in stride（from: through : by:){}<br>By为步长，包括开头，包括结尾</li>
<li>.reversed()可以使其反向，如stride().reversed()</li>
<li>repeat-while先运行一次，在进行判断</li>
<li>.count获得字符串的长度</li>
<li>.endIndex获取的为string最后一个字符的后一位的Index</li>
<li>若要获取最后一位的Index，则string.index(before:string.endIndex)</li>
<li>知道相对于startIndex偏移位置，获取Index，则<br>string.index(string.startIndex，ofsetBy：3）ofsetBy后面加的为偏移量<br>获取所要打印的字符串首位Index和末尾Index后，可以通过string[a…b]来获取a到bIndex范围的字符串</li>
<li>.firstIndex(of:””)可以获取某个字符的Index，但其为optional类型的，需要通过??来确保其为Index类型</li>
<li>.prefix(Int)可以直接获取字符串的前几个字符</li>
<li>..&lt;string.endIndex，可以到字符串的最后一位</li>
<li>.contains(“Character”)用于判断字符串内是否包含某个字符，为Bool类型的值</li>
<li>.contains(where:String.contains(“String”)用于判断字符串内是否包含某个字符串，为Bool类型的值</li>
<li>.hasPrefix(“String”)(判断字符串是否有前缀</li>
<li>.hasSuffix(“String”)(判断字符串是否有后缀</li>
<li>追加字符串.append(“String”)</li>
<li>插入字符串.insert(contentsOf:”String”,at:Index)</li>
<li>替换字符串.replaceSubrange(Range(Index),with”String”)(通过Index范围)</li>
<li>删除字符串.remove(Range(Index)) </li>
<li>“””<br>“””三个引号括起来后可以打印里面的内容，注意引号要对齐<br>#“ ”#里面的东西都当成字符串</li>
<li>可以通过初始化器创建一个数组<br>var a &#x3D; <a href="">Int</a><br>var b &#x3D; Array<Int>()<br>var c &#x3D; Array(repeating:-1,count:3)<br>构造一个含三个-1的数组</li>
<li>插入数组元素.insert(元素,at:数组下标)</li>
<li>很多类似字符串，将Range（Index）化成下标</li>
<li>.sort({})通过一个匿名函数（闭包）来将数组进行排序</li>
<li>.filter({})通过一个匿名函数（闭包）来将数组进行过滤，返回一个新的</li>
<li>array[0…]表示从数组的第一位到最后一位</li>
<li>remove(元素)可以直接删除数组里的元素</li>
<li>dictionary.update(value,forKey:key)若有key则更新值，若没有则在原字典添加上一个键值对</li>
<li>dictionary[key ?? “Unknown”] &#x3D; value修改键对应的值</li>
<li>dictionary.remove(forKey:key)删除key对应的value</li>
<li>断言assert一般用于类型判断</li>
<li>guard拦截语句(守护语句)，可用于处理optional类型的值<br>guard let value &#x3D; a(optional类型的） {}</li>
<li>Inout关键字param:inout Int 在值传递时变成引用传递，可改变参数的值，在使用时要在参数名称前加&amp;，如&amp;a（和指针有点像）</li>
<li>匿名函数，没有参数，没有返回值<br>var b:()-&gt;Void &#x3D; {()-&gt;Void in return…},可以放在参数类型为()-&gt;Void的函数里</li>
<li>若一个函数没有参数，没有返回值，用闭包实现函数赋值时可以省略in和前面的函数体部分<br>var<br>Var c &#x3D; {函数实现部分}<br>func test(param:(Int,Int)-&gt;Int){<br>print(param(10,20))<br>}<br>test(param: {$0 + $1})<br>test(param: {return $0 + $1})<br>test(param: {(a:Int,b:Int)-&gt;Int in<br>return  a + b<br>})</li>
<li>类型大驼峰，变量名小驼峰</li>
<li>枚举可以定义枚举类型值，也可以给每个枚举设定类型<br>如enum TestEnum:Int{ case a &#x3D; 1<br>case b &#x3D; 2<br>}<br>case a（String）<br>用TestEnum.a.rawValue可以获取枚举的原始值</li>
<li>若要遍历枚举，则设定枚举类型为CaseIterable</li>
<li>通过.allcase获取枚举的全部case</li>
<li>在结构体中只有在方法前面加关键字mutating才能调用这个方法对这个结构体的属性进行修改</li>
<li>Static let静态属性，只能通过结构体来调用</li>
<li>结构体实例调用为值传递，实例为常量，改变不了结构体属性</li>
<li>结构体内部给变量加上private说明此变量只有在结构体内部才能使用<br>类中构造器要调用其它构造器的值永convenience init</li>
<li>Static func静态方法只能在类中调用，不能在实例中调用</li>
<li>类实例设置为let，仍然可以改变实例中的var属性</li>
<li>AnyObject可以赋一个类的类型<br>Any可以赋任何一个类型</li>
<li>子类对象对父类的一个引用，生成对象叫做实例化，对象&#x3D;实例</li>
<li>在类中方法前面加上private说明此方法只能在类中使用，而加上public说明既可以在类中使用，也可以在类外面使用</li>
<li>父类类型的一个引用指向子类类型<br>var stu:Person &#x3D; Student(name:”student”,age:18)</li>
<li>向下类型转换<br>var stu:Any &#x3D; Student(name:”student”,age:18)<br>var s &#x3D; stu as? Student<br>print(s?.getName())<br>print(s!.getAge())<br>If let s &#x3D; stu as? Student{}</li>
<li>每当你定义一个新的结构体或者类时，你都是定义了一个新的 Swift 类型。请使用 UpperCamelCase 这种方式来命名类型（如这里的 SomeClass 和 SomeStructure），以便符合标准 Swift 类型的大写命名风格（如 String，Int和 Bool）。请使用 lowerCamelCase 这种方式来命名属性和方法（如 frameRate 和 incrementCount），以便和类型名区分。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://linhongyu0090.github.io/2022/04/17/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="cl239vo2p0004s6j0fejdbv6m" data-title="Swift学习笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C-学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/17/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-04-17T08:35:33.000Z" itemprop="datePublished">2022-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/17/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">C++学习笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="C-学习笔记"><a href="#C-学习笔记" class="headerlink" title="C++学习笔记"></a>C++学习笔记</h1><ol>
<li>string的length和size都是O（n）</li>
<li>nth_element(arr.begin(),arr.begin()+3,arr.end());<br>O（n）比sort排序快</li>
<li>1s时限内能做的运算次数大约为1e8，根据复杂度来算是否会超时</li>
<li>G++在输出double时不能用%lf，要用%f</li>
<li>注意多组拥立时的EOF、初始化，初始化的常数时间也得估计好</li>
<li>int表示范围-32769～32767</li>
<li>单精度float，占用4个字节，有效数字范围为7位有效数字，赋值时末尾加个f</li>
<li>双精度double，占用8个字节，有效数字范围为15～16个有效数字</li>
<li>默认情况下，输出一个小数会显示6位有效数字</li>
<li>a对应的ASICII码为65，A对应的ASCII码为97</li>
<li>转义字符：</li>
</ol>
<ul>
<li>反斜杠 \</li>
<li>水平制表符 \t</li>
</ul>
<ol start="12">
<li>swith语句判断时候只能是整形或字符型，不可以是一个区间</li>
<li>一维数组名的用途：</li>
</ol>
<ul>
<li>可以统计整个数组在内存的长度</li>
<li>可以获取数组在内存中的首地址</li>
</ul>
<ol start="14">
<li>C++ 0x代表十六进制</li>
<li>二维数组定义事一定要定义列数</li>
<li>二维数组名的用途：</li>
</ol>
<ul>
<li>可以统计整个数组在内存的长度</li>
<li>可以获取数组在内存中的首地址</li>
</ul>
<ol start="17">
<li><p>自己定义的函数写在main函数前面</p>
</li>
<li><p>值传递时，形参发生任何的改变都不会影响实参</p>
</li>
<li><p>函数声明后面有分号，函数定义后面没有</p>
</li>
<li><p>32位操作系统中指针占4个字节，64位操作系统中指针占8个字节</p>
</li>
<li><p>空指针用于给指针变量进行初始化，不可以进行访问，0～255之间的内存编号是系统占用的，因此不可以访问</p>
</li>
<li><p>const int*常量指针，指向常量的指针（可以理解为常量的<strong>指针</strong>），指针的指向可以修改，但是指针指向的值不可以修改</p>
</li>
<li><p>int* const p 指针常量，指针类型的变量(可以理解为指针的常量)，指针的指向不可以修改，指针指向的值可以修改</p>
</li>
<li><p>const int* const p 指针指向的值和指针的指向都不可以修改</p>
</li>
<li><p>初始结构体的方式:</p>
<ul>
<li>struct Student s1;</li>
<li>struct Student s2 &#x3D; {…}</li>
<li>在定义结构体时顺便创建结构体变量</li>
</ul>
</li>
<li><p>结构体定义时struct关键字不能省略，使用时可以省略</p>
</li>
<li><p>数组作为函数参数，只能是指针传递</p>
</li>
<li><p>case语句中不可以定义变量，加了{}后相当于在语句块中定义变量就可以</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;请输入删除联系人的姓名：&quot;</span> &lt;&lt; endl;</span><br><span class="line">                string name;</span><br><span class="line">                cin &gt;&gt; name;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isExist</span>(&amp;abs,name) == <span class="number">-1</span>)&#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;查无此人&quot;</span> &lt;&lt; endl;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;找到此人&quot;</span> &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++程序在运行时，将内存划分为4个区域：</p>
</li>
</ol>
<ul>
<li>代码区：存放函数题的二进制代码，由操作系统进行管理的</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</li>
<li>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收</li>
</ul>
<ol start="30">
<li>变量本质就是内存，申请完内存就是结构体变量了</li>
<li>引用：给变量起别名，数据类型  &amp;别名 &#x3D; 原名</li>
</ol>
<ul>
<li>引用必须初始化</li>
<li>引用初始化后不可以修改</li>
</ul>
<ol start="32">
<li>引用传递，形参会修饰实参</li>
<li>引用做函数的返回值：</li>
</ol>
<ul>
<li>不要返回局部变量的引用</li>
<li>函数的调用可以作为左值</li>
</ul>
<ol start="34">
<li>静态变量存放在全局去，全局区上的数据在程序结束后系统释放。</li>
<li>局部变量存放在栈区</li>
<li>引用本质是指针常量</li>
<li>1.需要首先明确的是，形参改变实参这种情况只可能发生在地址传递或引用传递之中。2.“ 防止形参改变实参”的意思是：在函数中可能会对形参的值进行修改，但是我们有时又不想让实参跟着改变，那么就可以用const来修饰形参。</li>
<li>如果某个位置已经又了默认参数，那么从这个位置往后，从左到右都必须有默认值</li>
<li>如果函数声明有默认参数，函数实现就不能有默认参数，声明和实现只能有一个有默认参数</li>
<li>占位参数也可以有默认参数</li>
<li>函数重载（函数名相同，提高复用性）满足条件:</li>
</ol>
<ul>
<li>同一作用域下</li>
<li>函数名称相同</li>
<li>函数参数类型不同，或者个数不同，或者顺序不同</li>
</ul>
<p><strong>注意：函数的返回值不可以作为函数重载的条件</strong><br>42. 函数重载不要默认参数，避免二义性出现<br>43. c++面向对象的三大特性：封装、继承、多态<br>44. 通过类来创建一个对象的过程就叫实例化<br>45. 类的成员一般加m_前缀（member），可以清晰的表示他是一个类的成员<br>46. 类中的属性和行为统称为成员</p>
<ul>
<li>属性：成员属性，成员变量</li>
<li>行为：成员函数，成员方法</li>
</ul>
<ol start="47">
<li>三种访问权限：</li>
</ol>
<ul>
<li>公共权限 public 成员类内可以访问 类外也可以访问</li>
<li>保护权限 protected  成员类内可以访问 类外不可以访问 子类可以访问父类的保护内容</li>
<li>私有权限 private 成员类内可以访问 类外不可以访问 子类不可以访问父类的保护内容</li>
</ul>
<ol start="48">
<li>struct和class默认的访问权限不同：</li>
</ol>
<ul>
<li>struct默认权限为公共</li>
<li>class默认权限为私有</li>
</ul>
<ol start="49">
<li>成员属性设置为私有：</li>
</ol>
<ul>
<li>可以自己控制读写权限</li>
<li>对于写权限，我们可以检测数据的有效性</li>
</ul>
<ol start="50">
<li>静态成员变量：</li>
</ol>
<ul>
<li>所有对象共享一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ul>
<ol start="51">
<li>静态成员变量不属于有某个对象上，所有成员共享同一份数据,静态成员变量也是有访问权限的，类外访问不到私有的静态成员变量。</li>
<li>静态成员变量有两种访问方式：</li>
</ol>
<ul>
<li>通过对象进行访问</li>
<li>通过类名进行访问</li>
</ul>
<ol start="53">
<li>静态成员函数（也有访问权限）:</li>
</ol>
<ul>
<li>所有对象共享一个函数</li>
<li>静态成员函数只能访问静态成员变量,不可访问不静态成员变量，无法区分是那个对象的非静态成员变量</li>
</ul>
<ol start="54">
<li>只有非静态成员变量才属于类的对象上,静态成员变量、非静态成员函数和静态成员函数都不属于类的对象上</li>
<li>空对象占用内存空间为1，c++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置，每个空对象也应该有一个独一无二的内存地址</li>
<li><strong>this指针指向被调用的成员函数所属的对象</strong>，this指针是隐含每一个非静态成员函数内的一种指针，this指针不需要定义，直接使用就可以。</li>
<li>this指针的用途：</li>
</ol>
<ul>
<li>当形参和实参相同时，可以用this指针来区分，（解决名称冲突）</li>
<li>在类的非静态成员函数中返回对象本身，可以用return *this</li>
</ul>
<ol start="58">
<li>如果要返回本体，要用引用的方式进行返回：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Person&amp; <span class="title">PersonAddAge</span><span class="params">(Person&amp; p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>常函数：</li>
</ol>
<ul>
<li>成员函数后加const后我们称这个函数为常函数</li>
<li><strong>常函数内不可以修改成员属性</strong></li>
<li>成员属性声明时加关键字mutable，在常函数中可以修改<br>常对象：</li>
<li>声明对象前加const称该对象为常对象</li>
<li>常对象只能调用常函数</li>
</ul>
<ol start="61">
<li>this指针的本质是指针常量，指针的指向不可以修改 </li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="comment">// this-&gt;m_A = 100;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
this相当于 const Person* const this(常指针常量)，在成员函数后面加const，修饰的是this指向，让指针指向的值也不可以修改.</li>
<li>属性前加mutable，在常函数中可以修改此属性的值</li>
<li>在对象前加const变成常对象，不可以修改对象的属性,常对象只能调用常函数，不可以调用成员函数，因为成员函数可以修改属性</li>
<li>全局函数函数申明加到要访问的类中，前面加上friend访问权限，这样全局函数就可以访问到该类中的private属性和方法</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//类外写构造函数</span></span><br><span class="line">Building::<span class="built_in">Building</span>()&#123;</span><br><span class="line">    m_SettingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类外写成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友类正在访问：&quot;</span> &lt;&lt; building-&gt;m_SettingRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">在函数名称前加上作用域</span><br></pre></td></tr></table></figure></li>
<li>在要访问的类中加上class声明语句，并且前面加上friend关键字，这个类的private属性和方法就可以被friend类访问</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GoodGay</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GoodGay</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;<span class="comment">//让visit函数可以访问Building中私有成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>;<span class="comment">//让visit函数不可以访问Building中私有成员</span></span><br><span class="line"></span><br><span class="line">    Building * building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SettingRoom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;m_B = &quot;</span> &lt;&lt; p.m_B;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
重载左移运算符配合友元可以实现输出自定义数据类型</li>
<li>赋值运算符就是从左往右运算的</li>
<li>函数调用运算符（）重载，由于使用起啦非常类似于函数调用，因此称为仿函数，仿函数非常灵活，没有固定的写法</li>
<li>默认的访问属性为private,保证了数据的安全性 而c语言的结构体中的默认访问属性为pubic</li>
<li>子类和父类同名属性和函数要加上作用域<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br></pre></td></tr></table></figure></li>
<li>如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏父类中所有同名成员函数，如果想访问到父类中被隐藏的同名函数，要加作用域</li>
<li>cout &lt;&lt; “Base下m_A &#x3D; “ &lt;&lt; Son::Base::m_A &lt;&lt; endl;第一个::代表通过类名的方式访问，第二个::代表访问父类作用域</li>
<li>find查找是从左往右，rfind查找是从右往左，find找到字符串后但会查找的第一个字符位置，找不到返回1，replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li>
<li>at会进行越界检查[]不会</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://linhongyu0090.github.io/2022/04/17/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="cl239vo2j0000s6j0ap001vp2" data-title="C++学习笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/17/hello-world/" class="article-date">
  <time class="dt-published" datetime="2022-04-17T04:46:02.830Z" itemprop="datePublished">2022-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/17/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://linhongyu0090.github.io/2022/04/17/hello-world/" data-id="cl239vo2l0001s6j07jip4752" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/04/17/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">C语言学习笔记</a>
          </li>
        
          <li>
            <a href="/2022/04/17/UIkit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">UIkit学习笔记</a>
          </li>
        
          <li>
            <a href="/2022/04/17/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Swift学习笔记</a>
          </li>
        
          <li>
            <a href="/2022/04/17/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">C++学习笔记</a>
          </li>
        
          <li>
            <a href="/2022/04/17/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 linhongyu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>