<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>C++学习笔记 | 林宏宇的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="C++学习笔记 string的length和size都是O（n） nth_element(arr.begin(),arr.begin()+3,arr.end());O（n）比sort排序快 1s时限内能做的运算次数大约为1e8，根据复杂度来算是否会超时 G++在输出double时不能用%lf，要用%f 注意多组拥立时的EOF、初始化，初始化的常数时间也得估计好 int表示范围-32769～3276">
<meta property="og:type" content="article">
<meta property="og:title" content="C++学习笔记">
<meta property="og:url" content="http://linhongyu0090.github.io/2022/04/17/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="林宏宇的博客">
<meta property="og:description" content="C++学习笔记 string的length和size都是O（n） nth_element(arr.begin(),arr.begin()+3,arr.end());O（n）比sort排序快 1s时限内能做的运算次数大约为1e8，根据复杂度来算是否会超时 G++在输出double时不能用%lf，要用%f 注意多组拥立时的EOF、初始化，初始化的常数时间也得估计好 int表示范围-32769～3276">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-04-17T08:35:33.000Z">
<meta property="article:modified_time" content="2022-04-17T08:36:12.187Z">
<meta property="article:author" content="linhongyu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="林宏宇的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">林宏宇的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://linhongyu0090.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-C-学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/17/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-04-17T08:35:33.000Z" itemprop="datePublished">2022-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      C++学习笔记
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="C-学习笔记"><a href="#C-学习笔记" class="headerlink" title="C++学习笔记"></a>C++学习笔记</h1><ol>
<li>string的length和size都是O（n）</li>
<li>nth_element(arr.begin(),arr.begin()+3,arr.end());<br>O（n）比sort排序快</li>
<li>1s时限内能做的运算次数大约为1e8，根据复杂度来算是否会超时</li>
<li>G++在输出double时不能用%lf，要用%f</li>
<li>注意多组拥立时的EOF、初始化，初始化的常数时间也得估计好</li>
<li>int表示范围-32769～32767</li>
<li>单精度float，占用4个字节，有效数字范围为7位有效数字，赋值时末尾加个f</li>
<li>双精度double，占用8个字节，有效数字范围为15～16个有效数字</li>
<li>默认情况下，输出一个小数会显示6位有效数字</li>
<li>a对应的ASICII码为65，A对应的ASCII码为97</li>
<li>转义字符：</li>
</ol>
<ul>
<li>反斜杠 \</li>
<li>水平制表符 \t</li>
</ul>
<ol start="12">
<li>swith语句判断时候只能是整形或字符型，不可以是一个区间</li>
<li>一维数组名的用途：</li>
</ol>
<ul>
<li>可以统计整个数组在内存的长度</li>
<li>可以获取数组在内存中的首地址</li>
</ul>
<ol start="14">
<li>C++ 0x代表十六进制</li>
<li>二维数组定义事一定要定义列数</li>
<li>二维数组名的用途：</li>
</ol>
<ul>
<li>可以统计整个数组在内存的长度</li>
<li>可以获取数组在内存中的首地址</li>
</ul>
<ol start="17">
<li><p>自己定义的函数写在main函数前面</p>
</li>
<li><p>值传递时，形参发生任何的改变都不会影响实参</p>
</li>
<li><p>函数声明后面有分号，函数定义后面没有</p>
</li>
<li><p>32位操作系统中指针占4个字节，64位操作系统中指针占8个字节</p>
</li>
<li><p>空指针用于给指针变量进行初始化，不可以进行访问，0～255之间的内存编号是系统占用的，因此不可以访问</p>
</li>
<li><p>const int*常量指针，指向常量的指针（可以理解为常量的<strong>指针</strong>），指针的指向可以修改，但是指针指向的值不可以修改</p>
</li>
<li><p>int* const p 指针常量，指针类型的变量(可以理解为指针的常量)，指针的指向不可以修改，指针指向的值可以修改</p>
</li>
<li><p>const int* const p 指针指向的值和指针的指向都不可以修改</p>
</li>
<li><p>初始结构体的方式:</p>
<ul>
<li>struct Student s1;</li>
<li>struct Student s2 &#x3D; {…}</li>
<li>在定义结构体时顺便创建结构体变量</li>
</ul>
</li>
<li><p>结构体定义时struct关键字不能省略，使用时可以省略</p>
</li>
<li><p>数组作为函数参数，只能是指针传递</p>
</li>
<li><p>case语句中不可以定义变量，加了{}后相当于在语句块中定义变量就可以</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;请输入删除联系人的姓名：&quot;</span> &lt;&lt; endl;</span><br><span class="line">                string name;</span><br><span class="line">                cin &gt;&gt; name;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isExist</span>(&amp;abs,name) == <span class="number">-1</span>)&#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;查无此人&quot;</span> &lt;&lt; endl;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;找到此人&quot;</span> &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++程序在运行时，将内存划分为4个区域：</p>
</li>
</ol>
<ul>
<li>代码区：存放函数题的二进制代码，由操作系统进行管理的</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</li>
<li>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收</li>
</ul>
<ol start="30">
<li>变量本质就是内存，申请完内存就是结构体变量了</li>
<li>引用：给变量起别名，数据类型  &amp;别名 &#x3D; 原名</li>
</ol>
<ul>
<li>引用必须初始化</li>
<li>引用初始化后不可以修改</li>
</ul>
<ol start="32">
<li>引用传递，形参会修饰实参</li>
<li>引用做函数的返回值：</li>
</ol>
<ul>
<li>不要返回局部变量的引用</li>
<li>函数的调用可以作为左值</li>
</ul>
<ol start="34">
<li>静态变量存放在全局去，全局区上的数据在程序结束后系统释放。</li>
<li>局部变量存放在栈区</li>
<li>引用本质是指针常量</li>
<li>1.需要首先明确的是，形参改变实参这种情况只可能发生在地址传递或引用传递之中。2.“ 防止形参改变实参”的意思是：在函数中可能会对形参的值进行修改，但是我们有时又不想让实参跟着改变，那么就可以用const来修饰形参。</li>
<li>如果某个位置已经又了默认参数，那么从这个位置往后，从左到右都必须有默认值</li>
<li>如果函数声明有默认参数，函数实现就不能有默认参数，声明和实现只能有一个有默认参数</li>
<li>占位参数也可以有默认参数</li>
<li>函数重载（函数名相同，提高复用性）满足条件:</li>
</ol>
<ul>
<li>同一作用域下</li>
<li>函数名称相同</li>
<li>函数参数类型不同，或者个数不同，或者顺序不同</li>
</ul>
<p><strong>注意：函数的返回值不可以作为函数重载的条件</strong><br>42. 函数重载不要默认参数，避免二义性出现<br>43. c++面向对象的三大特性：封装、继承、多态<br>44. 通过类来创建一个对象的过程就叫实例化<br>45. 类的成员一般加m_前缀（member），可以清晰的表示他是一个类的成员<br>46. 类中的属性和行为统称为成员</p>
<ul>
<li>属性：成员属性，成员变量</li>
<li>行为：成员函数，成员方法</li>
</ul>
<ol start="47">
<li>三种访问权限：</li>
</ol>
<ul>
<li>公共权限 public 成员类内可以访问 类外也可以访问</li>
<li>保护权限 protected  成员类内可以访问 类外不可以访问 子类可以访问父类的保护内容</li>
<li>私有权限 private 成员类内可以访问 类外不可以访问 子类不可以访问父类的保护内容</li>
</ul>
<ol start="48">
<li>struct和class默认的访问权限不同：</li>
</ol>
<ul>
<li>struct默认权限为公共</li>
<li>class默认权限为私有</li>
</ul>
<ol start="49">
<li>成员属性设置为私有：</li>
</ol>
<ul>
<li>可以自己控制读写权限</li>
<li>对于写权限，我们可以检测数据的有效性</li>
</ul>
<ol start="50">
<li>静态成员变量：</li>
</ol>
<ul>
<li>所有对象共享一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ul>
<ol start="51">
<li>静态成员变量不属于有某个对象上，所有成员共享同一份数据,静态成员变量也是有访问权限的，类外访问不到私有的静态成员变量。</li>
<li>静态成员变量有两种访问方式：</li>
</ol>
<ul>
<li>通过对象进行访问</li>
<li>通过类名进行访问</li>
</ul>
<ol start="53">
<li>静态成员函数（也有访问权限）:</li>
</ol>
<ul>
<li>所有对象共享一个函数</li>
<li>静态成员函数只能访问静态成员变量,不可访问不静态成员变量，无法区分是那个对象的非静态成员变量</li>
</ul>
<ol start="54">
<li>只有非静态成员变量才属于类的对象上,静态成员变量、非静态成员函数和静态成员函数都不属于类的对象上</li>
<li>空对象占用内存空间为1，c++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置，每个空对象也应该有一个独一无二的内存地址</li>
<li><strong>this指针指向被调用的成员函数所属的对象</strong>，this指针是隐含每一个非静态成员函数内的一种指针，this指针不需要定义，直接使用就可以。</li>
<li>this指针的用途：</li>
</ol>
<ul>
<li>当形参和实参相同时，可以用this指针来区分，（解决名称冲突）</li>
<li>在类的非静态成员函数中返回对象本身，可以用return *this</li>
</ul>
<ol start="58">
<li>如果要返回本体，要用引用的方式进行返回：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Person&amp; <span class="title">PersonAddAge</span><span class="params">(Person&amp; p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>常函数：</li>
</ol>
<ul>
<li>成员函数后加const后我们称这个函数为常函数</li>
<li><strong>常函数内不可以修改成员属性</strong></li>
<li>成员属性声明时加关键字mutable，在常函数中可以修改<br>常对象：</li>
<li>声明对象前加const称该对象为常对象</li>
<li>常对象只能调用常函数</li>
</ul>
<ol start="61">
<li>this指针的本质是指针常量，指针的指向不可以修改 </li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="comment">// this-&gt;m_A = 100;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
this相当于 const Person* const this(常指针常量)，在成员函数后面加const，修饰的是this指向，让指针指向的值也不可以修改.</li>
<li>属性前加mutable，在常函数中可以修改此属性的值</li>
<li>在对象前加const变成常对象，不可以修改对象的属性,常对象只能调用常函数，不可以调用成员函数，因为成员函数可以修改属性</li>
<li>全局函数函数申明加到要访问的类中，前面加上friend访问权限，这样全局函数就可以访问到该类中的private属性和方法</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//类外写构造函数</span></span><br><span class="line">Building::<span class="built_in">Building</span>()&#123;</span><br><span class="line">    m_SettingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类外写成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友类正在访问：&quot;</span> &lt;&lt; building-&gt;m_SettingRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">在函数名称前加上作用域</span><br></pre></td></tr></table></figure></li>
<li>在要访问的类中加上class声明语句，并且前面加上friend关键字，这个类的private属性和方法就可以被friend类访问</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GoodGay</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GoodGay</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;<span class="comment">//让visit函数可以访问Building中私有成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>;<span class="comment">//让visit函数不可以访问Building中私有成员</span></span><br><span class="line"></span><br><span class="line">    Building * building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SettingRoom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;m_B = &quot;</span> &lt;&lt; p.m_B;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
重载左移运算符配合友元可以实现输出自定义数据类型</li>
<li>赋值运算符就是从左往右运算的</li>
<li>函数调用运算符（）重载，由于使用起啦非常类似于函数调用，因此称为仿函数，仿函数非常灵活，没有固定的写法</li>
<li>默认的访问属性为private,保证了数据的安全性 而c语言的结构体中的默认访问属性为pubic</li>
<li>子类和父类同名属性和函数要加上作用域<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br></pre></td></tr></table></figure></li>
<li>如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏父类中所有同名成员函数，如果想访问到父类中被隐藏的同名函数，要加作用域</li>
<li>cout &lt;&lt; “Base下m_A &#x3D; “ &lt;&lt; Son::Base::m_A &lt;&lt; endl;第一个::代表通过类名的方式访问，第二个::代表访问父类作用域</li>
<li>find查找是从左往右，rfind查找是从右往左，find找到字符串后但会查找的第一个字符位置，找不到返回1，replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li>
<li>at会进行越界检查[]不会</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://linhongyu0090.github.io/2022/04/17/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="cl24pa6qi0000vfj0g2jm99z7" data-title="C++学习笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/04/17/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Swift学习笔记
        
      </div>
    </a>
  
  
    <a href="/2022/04/17/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/04/18/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Python学习笔记</a>
          </li>
        
          <li>
            <a href="/2022/04/17/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Git学习笔记</a>
          </li>
        
          <li>
            <a href="/2022/04/17/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">C语言学习笔记</a>
          </li>
        
          <li>
            <a href="/2022/04/17/UIkit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">UIkit学习笔记</a>
          </li>
        
          <li>
            <a href="/2022/04/17/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Swift学习笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 linhongyu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>